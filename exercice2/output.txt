RUN NO OPTIMISATION
n=100 
RDTSC instruction:
 9102870.000000 cycles measured => 0.003371 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 3655.250000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.003655 seconds. 

C gettimeofday() function:
 0.003646 seconds measured

n=200 
RDTSC instruction:
 72952522.000000 cycles measured => 0.027019 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 29057.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.029057 seconds. 

C gettimeofday() function:
 0.029034 seconds measured

n=300 
RDTSC instruction:
 245319576.000000 cycles measured => 0.090859 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 98621.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.098621 seconds. 

C gettimeofday() function:
 0.098427 seconds measured

n=400 
RDTSC instruction:
 601896191.000000 cycles measured => 0.222925 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 239204.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.239204 seconds. 

C gettimeofday() function:
 0.240967 seconds measured

n=500 
RDTSC instruction:
 1181908811.000000 cycles measured => 0.437744 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 472889.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.472889 seconds. 

C gettimeofday() function:
 0.479636 seconds measured

n=600 
RDTSC instruction:
 2036199002.000000 cycles measured => 0.754148 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 835566.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.835566 seconds. 

C gettimeofday() function:
 0.816426 seconds measured

n=700 
RDTSC instruction:
 3307251007.000000 cycles measured => 1.224908 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1320161.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.320161 seconds. 

C gettimeofday() function:
 1.317667 seconds measured

n=800 
RDTSC instruction:
 4885165963.000000 cycles measured => 1.809321 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1948955.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.948955 seconds. 

C gettimeofday() function:
 1.936423 seconds measured

n=900 
RDTSC instruction:
 6998298818.000000 cycles measured => 2.591963 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 2768895.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 2.768895 seconds. 

C gettimeofday() function:
 2.752047 seconds measured

n=1000 
RDTSC instruction:
 9422353610.000000 cycles measured => 3.489761 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 3860873.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 3.860873 seconds. 

C gettimeofday() function:
 3.772642 seconds measured

n=1100 
RDTSC instruction:
 12570256347.000000 cycles measured => 4.655650 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 5036624.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 5.036624 seconds. 

C gettimeofday() function:
 5.030629 seconds measured

n=1200 
RDTSC instruction:
 16620476517.000000 cycles measured => 6.155732 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 6775075.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 6.775075 seconds. 

C gettimeofday() function:
 6.711645 seconds measured

n=1300 
RDTSC instruction:
 20947859176.000000 cycles measured => 7.758466 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 8383122.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 8.383122 seconds. 

C gettimeofday() function:
 8.495250 seconds measured

n=1400 
RDTSC instruction:
 27077661363.000000 cycles measured => 10.028763 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 10799163.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 10.799163 seconds. 

C gettimeofday() function:
 11.151533 seconds measured

n=1500 
RDTSC instruction:
 33689801895.000000 cycles measured => 12.477704 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 13423003.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 13.423003 seconds. 

C gettimeofday() function:
 13.428726 seconds measured

RUN OPTIMISATION
RUN VECTOR
n=100 
RDTSC instruction:
 718446.000000 cycles measured => 0.000266 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 292.898438 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000293 seconds. 

C gettimeofday() function:
 0.000293 seconds measured

n=200 
RDTSC instruction:
 5833809.000000 cycles measured => 0.002161 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 2378.125000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.002378 seconds. 

C gettimeofday() function:
 0.002349 seconds measured

n=300 
RDTSC instruction:
 21627788.000000 cycles measured => 0.008010 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 8776.500000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.008776 seconds. 

C gettimeofday() function:
 0.008387 seconds measured

n=400 
RDTSC instruction:
 56107521.000000 cycles measured => 0.020781 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 22398.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.022398 seconds. 

C gettimeofday() function:
 0.022432 seconds measured

n=500 
RDTSC instruction:
 111089481.000000 cycles measured => 0.041144 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 44685.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.044685 seconds. 

C gettimeofday() function:
 0.044302 seconds measured

n=600 
RDTSC instruction:
 193568093.000000 cycles measured => 0.071692 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 78806.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.078806 seconds. 

C gettimeofday() function:
 0.078015 seconds measured

n=700 
RDTSC instruction:
 311542591.000000 cycles measured => 0.115386 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 125684.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.125684 seconds. 

C gettimeofday() function:
 0.125054 seconds measured

n=800 
RDTSC instruction:
 496585326.000000 cycles measured => 0.183920 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 193693.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.193693 seconds. 

C gettimeofday() function:
 0.197505 seconds measured

n=900 
RDTSC instruction:
 712785793.000000 cycles measured => 0.263995 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 293236.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.293236 seconds. 

C gettimeofday() function:
 0.290687 seconds measured

n=1000 
RDTSC instruction:
 964874806.000000 cycles measured => 0.357361 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 395039.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.395039 seconds. 

C gettimeofday() function:
 0.381174 seconds measured

n=1100 
RDTSC instruction:
 1300715581.000000 cycles measured => 0.481747 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 523144.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.523144 seconds. 

C gettimeofday() function:
 0.518942 seconds measured

n=1200 
RDTSC instruction:
 1761700038.000000 cycles measured => 0.652481 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 704694.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.704694 seconds. 

C gettimeofday() function:
 0.733032 seconds measured

n=1300 
RDTSC instruction:
 2456036513.000000 cycles measured => 0.909643 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 979653.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.979653 seconds. 

C gettimeofday() function:
 0.982909 seconds measured

n=1400 
RDTSC instruction:
 3189672380.000000 cycles measured => 1.181360 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1278228.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.278228 seconds. 

C gettimeofday() function:
 1.269348 seconds measured

n=1500 
RDTSC instruction:
 4095521249.000000 cycles measured => 1.516860 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1679260.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.679260 seconds. 

C gettimeofday() function:
 1.649611 seconds measured

