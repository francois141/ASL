RUN NO OPTIMISATION
n=100 
RDTSC instruction:
 9433375.000000 cycles measured => 0.003494 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 2467.937500 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.002468 seconds. 

C gettimeofday() function:
 0.002647 seconds measured

n=200 
RDTSC instruction:
 76329895.000000 cycles measured => 0.028270 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 21632.500000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.021632 seconds. 

C gettimeofday() function:
 0.022512 seconds measured

n=300 
RDTSC instruction:
 248802064.000000 cycles measured => 0.092149 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 67221.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.067221 seconds. 

C gettimeofday() function:
 0.071058 seconds measured

n=400 
RDTSC instruction:
 585296270.000000 cycles measured => 0.216776 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 158847.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.158847 seconds. 

C gettimeofday() function:
 0.169634 seconds measured

n=500 
RDTSC instruction:
 993092900.000000 cycles measured => 0.367812 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 311844.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.311844 seconds. 

C gettimeofday() function:
 0.307488 seconds measured

n=600 
RDTSC instruction:
 1760486720.000000 cycles measured => 0.652032 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 536226.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.536226 seconds. 

C gettimeofday() function:
 0.523475 seconds measured

n=700 
RDTSC instruction:
 2876909842.000000 cycles measured => 1.065522 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 836382.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.836382 seconds. 

C gettimeofday() function:
 0.895843 seconds measured

n=800 
RDTSC instruction:
 4508222850.000000 cycles measured => 1.669712 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1442610.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.442610 seconds. 

C gettimeofday() function:
 1.318179 seconds measured

n=900 
RDTSC instruction:
 6675301820.000000 cycles measured => 2.472334 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1933457.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.933457 seconds. 

C gettimeofday() function:
 1.874675 seconds measured

n=1000 
RDTSC instruction:
 9587237856.000000 cycles measured => 3.550829 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 2553636.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 2.553636 seconds. 

C gettimeofday() function:
 2.540770 seconds measured

n=1100 
RDTSC instruction:
 11890935366.000000 cycles measured => 4.404050 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 3485553.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 3.485553 seconds. 

C gettimeofday() function:
 3.558517 seconds measured

n=1200 
RDTSC instruction:
 16595557780.000000 cycles measured => 6.146503 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 4921209.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 4.921209 seconds. 

C gettimeofday() function:
 4.504055 seconds measured

n=1300 
RDTSC instruction:
 18871735090.000000 cycles measured => 6.989532 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 6018352.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 6.018352 seconds. 

C gettimeofday() function:
 5.818770 seconds measured

n=1400 
RDTSC instruction:
 24909000552.000000 cycles measured => 9.225556 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 7175228.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 7.175228 seconds. 

C gettimeofday() function:
 7.096405 seconds measured

n=1500 
RDTSC instruction:
 30301062402.000000 cycles measured => 11.222616 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 8917348.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 8.917348 seconds. 

C gettimeofday() function:
 9.063239 seconds measured

RUN OPTIMISATION
n=100 
RDTSC instruction:
 2821972.000000 cycles measured => 0.001045 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 784.953125 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000785 seconds. 

C gettimeofday() function:
 0.000821 seconds measured

n=200 
RDTSC instruction:
 28379393.000000 cycles measured => 0.010511 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 7861.750000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.007862 seconds. 

C gettimeofday() function:
 0.008375 seconds measured

n=300 
RDTSC instruction:
 90447904.000000 cycles measured => 0.033499 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 26906.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.026906 seconds. 

C gettimeofday() function:
 0.027102 seconds measured

n=400 
RDTSC instruction:
 209945378.000000 cycles measured => 0.077758 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 63788.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.063788 seconds. 

C gettimeofday() function:
 0.072187 seconds measured

n=500 
RDTSC instruction:
 415748272.000000 cycles measured => 0.153981 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 123518.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.123518 seconds. 

C gettimeofday() function:
 0.141075 seconds measured

n=600 
RDTSC instruction:
 740861830.000000 cycles measured => 0.274393 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 246098.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.246098 seconds. 

C gettimeofday() function:
 0.243714 seconds measured

n=700 
RDTSC instruction:
 1295163388.000000 cycles measured => 0.479690 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 356584.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.356584 seconds. 

C gettimeofday() function:
 0.371196 seconds measured

n=800 
RDTSC instruction:
 1861470116.000000 cycles measured => 0.689433 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 531402.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.531402 seconds. 

C gettimeofday() function:
 0.553493 seconds measured

n=900 
RDTSC instruction:
 2649276680.000000 cycles measured => 0.981214 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 800548.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.800548 seconds. 

C gettimeofday() function:
 0.786579 seconds measured

n=1000 
RDTSC instruction:
 3817256482.000000 cycles measured => 1.413799 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1057693.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.057693 seconds. 

C gettimeofday() function:
 1.051710 seconds measured

n=1100 
RDTSC instruction:
 5224313878.000000 cycles measured => 1.934931 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1474133.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.474133 seconds. 

C gettimeofday() function:
 1.528440 seconds measured

n=1200 
RDTSC instruction:
 6534126738.000000 cycles measured => 2.420047 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1949467.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.949467 seconds. 

C gettimeofday() function:
 1.935047 seconds measured

n=1300 
RDTSC instruction:
 8439327276.000000 cycles measured => 3.125677 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 2511608.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 2.511608 seconds. 

C gettimeofday() function:
 2.671345 seconds measured

n=1400 
RDTSC instruction:
 11704734476.000000 cycles measured => 4.335087 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 3182865.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 3.182865 seconds. 

C gettimeofday() function:
 3.128445 seconds measured

n=1500 
RDTSC instruction:
 13343157364.000000 cycles measured => 4.941910 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 3905007.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 3.905007 seconds. 

C gettimeofday() function:
 3.913730 seconds measured

RUN VECTOR
n=100 
RDTSC instruction:
 749450.000000 cycles measured => 0.000278 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 223.726562 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.000224 seconds. 

C gettimeofday() function:
 0.000221 seconds measured

n=200 
RDTSC instruction:
 6121066.000000 cycles measured => 0.002267 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 2042.593750 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.002043 seconds. 

C gettimeofday() function:
 0.001934 seconds measured

n=300 
RDTSC instruction:
 24220942.000000 cycles measured => 0.008971 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 6846.250000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.006846 seconds. 

C gettimeofday() function:
 0.006701 seconds measured

n=400 
RDTSC instruction:
 56368029.000000 cycles measured => 0.020877 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 16646.500000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.016646 seconds. 

C gettimeofday() function:
 0.016227 seconds measured

n=500 
RDTSC instruction:
 115702816.000000 cycles measured => 0.042853 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 38017.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.038017 seconds. 

C gettimeofday() function:
 0.033613 seconds measured

n=600 
RDTSC instruction:
 199032122.000000 cycles measured => 0.073716 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 54139.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.054139 seconds. 

C gettimeofday() function:
 0.055515 seconds measured

n=700 
RDTSC instruction:
 345819906.000000 cycles measured => 0.128081 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 86850.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.086850 seconds. 

C gettimeofday() function:
 0.102138 seconds measured

n=800 
RDTSC instruction:
 513332264.000000 cycles measured => 0.190123 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 140147.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.140147 seconds. 

C gettimeofday() function:
 0.135697 seconds measured

n=900 
RDTSC instruction:
 776318420.000000 cycles measured => 0.287525 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 233792.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.233792 seconds. 

C gettimeofday() function:
 0.265250 seconds measured

n=1000 
RDTSC instruction:
 1254943398.000000 cycles measured => 0.464794 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 380704.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.380704 seconds. 

C gettimeofday() function:
 0.429265 seconds measured

n=1100 
RDTSC instruction:
 1882861090.000000 cycles measured => 0.697356 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 541678.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.541678 seconds. 

C gettimeofday() function:
 0.588972 seconds measured

n=1200 
RDTSC instruction:
 2636372238.000000 cycles measured => 0.976434 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 767645.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.767645 seconds. 

C gettimeofday() function:
 0.826169 seconds measured

n=1300 
RDTSC instruction:
 3430922122.000000 cycles measured => 1.270712 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 936994.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 0.936994 seconds. 

C gettimeofday() function:
 1.015349 seconds measured

n=1400 
RDTSC instruction:
 4197720568.000000 cycles measured => 1.554711 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1272942.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.272942 seconds. 

C gettimeofday() function:
 1.268890 seconds measured

n=1500 
RDTSC instruction:
 5404839790.000000 cycles measured => 2.001793 seconds, assuming frequency is 2700.000000 MHz. (change in source file if different)

C clock() function:
 1528408.000000 cycles measured. On some systems, this number seems to be actually computed from a timer in seconds then transformed into clock ticks using the variable CLOCKS_PER_SEC. Unfortunately, it appears that CLOCKS_PER_SEC is sometimes set improperly. (According to this variable, your computer should be running at 1.000000 MHz). In any case, dividing by this value should give a correct timing: 1.528408 seconds. 

C gettimeofday() function:
 1.572320 seconds measured

